## 基础篇
4.简述 defer 的执行顺序
    defer 是在return之后执行，函数推出之前执行。
    多个defer可以理解成一个栈，遵循后进先出原则。


## Slice篇
1.简述 slice 的底层原理，slice 和数组的区别是什么？
    slice是一个结构体，底层实现主要有3个参数：数组地址，len，cap，总共占用24个字节
    区别：
    1.数组的长度固定，slice可以动态增加
    2.函数传参不同：
        2.1 数组是值类型，函数传参会复制整个数组数据，占用额外的内存
        2.2 切片是引用类型，函数传参不会拷贝整个切片，底层共用同一个数组。
    3.计算数组长度的方式不同。

2.go slice的深拷贝和浅拷贝
    深拷贝：copy(slice1, slice2)、 遍历append赋值
    浅拷贝：默认赋值操作

3.slice 的扩容机制
    1.如果原有slice的长度小于1024，那么每次扩容就为原来的两倍
    2.如果原有slice的长度大于1024，那么每次扩容就为原来的1.25倍

4.slice 为什么不是线程安全的？
    slice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的

## Map篇
1.Golang 是如何实现 Maps 的？
    map的底层是一个指针，指向hmap,hmap的结构体中包含了bmap的数组
    bmap是主要存储键值对的结构，最多存储8组键值对，其中主要包含：tophash，8个键，8个值，溢出桶

2.Map遍历是无序的原因：
    每次遍历，会随机生成一个桶的编号，在从其中随机的cell开始遍历

3.go map冲突的解决方式：
    链式地址法
    开放寻址法
    
    python：开放寻址法
    java：链式寻址法
    go map：链式寻址法

4.Map和sync.Map的性能比较：
    sync.Map：适合读多写少的场景，因为可以无锁访问read map，减少了加锁对性能的影响

## Channels篇


## 协程篇
5.有缓存的管道和没有缓存的管道区别是什么？
    对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。
    对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。

## Mutex篇

## 调度模型
1.简述 Goroutine 的调度流程
    
    GMP模型：
    G：用来标识goroutine
    P：是管理者一组goroutine的队列，p会储存当前goroutine的上下文信息(函数指针，堆栈地址、地址边界)
       p会对自己管理的goroutine做一些调度，当消费完自己队列的，就去消费全局队列的，
       全局队列的也消费完，回去抢占其他p队列中的任务
    M：M是go运行时对操作系统内核的虚拟，M与内核线程是一一对应，goroutine最终是要放到M上运行的。
    三者的关系：p管理着一组G挂在M上
    单从系统调度的角度上来讲：Goroutine是由go运行时自己的调度器调度的，这个调度器使用了一个M：N的调度技术：
    1.goroutine的调度是在用户态下完成的，不涉及用户态和内核态的转换
    2.充分的使用了多核的硬件资源，把若干个goroutine均分到物理线程上


## 内存管理
1.简述 Golang 垃圾回收的机制
    三色标记法：
    1.新创建的对象默认颜色是白色
    2.GC回收从根节点一次遍历所有对象，把遍历到的对象从白色集合放入灰色集合。
    3.循环遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，直到灰色中无任何对象
    4.回收所有的白色标记表的对象.也就是回收垃圾
    缺点：需要STW，即要暂时停掉程序运行

    改进：混合写屏障机制
    通过混合写屏障，Golang实现了GC的增量与并发
    增量指的是: 将GC的过程打散，分多次执行来完成一次GC过程。
    并发指的是: GC过程中的一部分可以和用户程序一起并发执行。

    gc触发条件：
    1.手动gc
    2.内存增大了1倍
    3.默认2min触发了一次gc


## 并发编程






7.Channels 怎么保证线程安全？
8.Maps 是线程安全的吗？怎么解决它的并发安全问题？
9.Golang 的一个协程能保证绑定在一个内核线程上吗？
11.Golang 的协程可以自己主动让出 CPU 吗？