## 基础篇
4.简述 defer 的执行顺序
    defer 是在return之后执行，函数推出之前执行。
    多个defer可以理解成一个栈，遵循后进先出原则。


## Slice篇
6.简述 slice 的底层原理，slice 和数组的区别是什么？
    slice是一个结构体，底层实现主要有3个参数：数组地址，len，cap
    区别：
    1.数组的长度固定，slice可以动态增加
    2.函数传参不同：
        2.1 数组是值类型，函数传参会复制整个数组数据，占用额外的内存
        2.2 切片是引用类型，函数传参不会拷贝整个切片，底层共用同一个数组。
    3.计算数组长度的方式不同。
## Map篇
3.Golang 是如何实现 Maps 的？
## Channels篇

## 协程篇
5.有缓存的管道和没有缓存的管道区别是什么？
    对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。
    对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。

## Mutex篇

## 调度模型
1.简述 Goroutine 的调度流程
    
    GMP模型：
    G：用来标识goroutine
    P：是管理者一组goroutine的队列，p会储存当前goroutine的上下文信息(函数指针，堆栈地址、地址边界)
       p会对自己管理的goroutine做一些调度，当消费完自己队列的，就去消费全局队列的，
       全局队列的也消费完，回去抢占其他p队列中的任务
    M：M是go运行时对操作系统内核的虚拟，M与内核线程是一一对应，goroutine最终是要放到M上运行的。
    三者的关系：p管理着一组G挂在M上
    单从系统调度的角度上来讲：Goroutine是由go运行时自己的调度器调度的，这个调度器使用了一个M：N的调度技术：
    1.goroutine的调度是在用户态下完成的，不涉及用户态和内核态的转换
    2.充分的使用了多核的硬件资源，把若干个goroutine均分到物理线程上


## 内存管理
1.简述 Golang 垃圾回收的机制
    三色标记法：
    1.新创建的对象默认颜色是白色
    2.GC回收从根节点一次遍历所有对象，把遍历到的对象从白色集合放入灰色集合。
    3.循环遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，直到灰色中无任何对象
    4.回收所有的白色标记表的对象.也就是回收垃圾
    缺点：需要STW，即要暂时停掉程序运行

    改进：混合写屏障机制
    通过混合写屏障，Golang实现了GC的增量与并发
    增量指的是: 将GC的过程打散，分多次执行来完成一次GC过程。
    并发指的是: GC过程中的一部分可以和用户程序一起并发执行。

    gc触发条件：
    1.手动gc
    2.内存增大了1倍
    3.默认2min触发了一次gc


## 并发编程






7.Channels 怎么保证线程安全？
8.Maps 是线程安全的吗？怎么解决它的并发安全问题？
9.Golang 的一个协程能保证绑定在一个内核线程上吗？
11.Golang 的协程可以自己主动让出 CPU 吗？