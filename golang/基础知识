## 基础篇
1.简述 defer 的执行顺序
    defer 是在return之后执行，函数推出之前执行。
    多个defer可以理解成一个栈，遵循后进先出原则。


## Slice篇
1.简述 slice 的底层原理，slice 和数组的区别是什么？
    slice是一个结构体，底层实现主要有3个参数：数组地址，len，cap，总共占用24个字节
    区别：
    1.数组的长度固定，slice可以动态增加
    2.函数传参不同：
        2.1 数组是值类型，函数传参会复制整个数组数据，占用额外的内存
        2.2 切片是引用类型，函数传参不会拷贝整个切片，底层共用同一个数组。
    3.计算数组长度的方式不同。

2.go slice的深拷贝和浅拷贝
    深拷贝：copy(slice1, slice2)、 遍历append赋值
    浅拷贝：默认赋值操作

3.slice 的扩容机制
    1.如果原有slice的长度小于1024，那么每次扩容就为原来的两倍
    2.如果原有slice的长度大于1024，那么每次扩容就为原来的1.25倍

4.slice 为什么不是线程安全的？
    slice底层结构并没有使用加锁等方式，不支持并发读写，所以并不是线程安全的

## Map篇
1.Golang 是如何实现 Maps 的？
    map的底层是一个指针，指向hmap,hmap的结构体中包含了bmap的数组
    bmap是主要存储键值对的结构，最多存储8组键值对，其中主要包含：tophash，8个键，8个值，溢出桶

2.Map遍历是无序的原因：
    每次遍历，会随机生成一个桶的编号，在从其中随机的cell开始遍历

3.go map冲突的解决方式：
    链式地址法
    开放寻址法
    
    python：开放寻址法
    java：链式寻址法
    go map：链式寻址法

4.Map和sync.Map的性能比较：
    sync.Map：适合读多写少的场景，因为可以无锁访问read map，减少了加锁对性能的影响

## Channels篇
1.channel的底层实现原理：
    通过var或者是make创建的chan是一个存储在栈上的指针，占用8个字节，指向堆上的结构体hchan，hchan主要有4个部分：
    buf：环形缓冲数组---用于保存goroutine之间传递数据的环形数据
    sendx：写下标的位置---用于记录当前环形数据发送或接收数据的下标值
    recvx：读下标的位置
    sendq：读等待队列---用于保存从该chan发送或接收数据时被阻塞的goroutine队列
    recvq：写等待队列
    lock：锁---保证chan读取和写入数据时线程安全的互斥锁

2.channel 的特点：
    channel有3种状态：未初始化、正常、关闭、
    1.一个channel不能被多次关闭
    2.如果多个goroutine监听一个channel，channel的数据可能随机被某一个goroutine消费、而关闭的信号会通知所有的goroutine

3.有缓存的管道和没有缓存的管道区别是什么？
    对于无缓冲的 channel，发送方将阻塞该信道，直到接收方从该信道接收到数据为止，而接收方也将阻塞该信道，直到发送方将数据发送到该信道中为止。
    对于有缓存的 channel，发送方在没有空插槽（缓冲区使用完）的情况下阻塞，而接收方在信道为空的情况下阻塞。

4.如何控制goroutine并发的执行顺序？
    使用channel传递信号、从而控制并发执行的顺序

5.channel 共享内存有什么优点：
    优点：解耦生产者和消费者，可以降低并发中的耦合
    缺点：容易死锁

6.channel 死锁的场景：
    1.非缓冲channel只写不读
    2.非缓冲channel读在写之后
    3.缓冲channel写入超过缓冲区大小
    4.空读
    5.多个协程互相等待

## Mutex篇
1.Mutex的底层实现原理：
    Mutex的数据结构中：
    status标识锁的状态，32位的整型，用于表示：是否被锁定、是否被唤醒、是否处于饥饿模式等
    sema表示信号量，从而实现goroutine的阻塞与唤醒
    加锁的过程：获取锁---自旋---等待被唤醒---饥饿模式

2.互斥锁自旋的条件：
    1.锁已经被占用，且不处于饥饿模式下
    2.积累的自旋次数小于最大自旋次数4次
    3.cpu核数大于1
    4.有空闲的P
    5.当前goroutine所挂在的p下，没有其他goroutine


## 协程篇
1.goroutine的底层实现原理
    数据结构：
    1.唯一的goroutine的id
    2.上下文：栈指针的位置、
    3.栈
    goroutine的状态：
    空闲中、待运行、运行中、系统调用中、等待中、已中止
    创建：
    运行：
    阻塞：
    唤醒：
    退出：

2.goroutine和线程的区别：
    1.内存占用
    2.创建和销毁
    3.切换成本：

3.goroutine泄漏的场景：
    1.进行读写操作被阻塞
    2.代码死循环，资源无法被释放
    3.业务逻辑进入长时间等待，有不断新增的goroutine进入等待

    检查方法：
    开启pprof，查看goroutine的数量，runtime.gopark是一个阻塞函数。

4.如何控制并发goroutine的数量：
    通过channel管道传递数据，在程序执行之初，创建固定数量的goroutine


## 调度模型
1.简述 Goroutine 的调度流程
    GMP模型：
    G：用来标识goroutine
    P：是管理者一组goroutine的队列，p会储存当前goroutine的上下文信息(函数指针，堆栈地址、地址边界)
       p会对自己管理的goroutine做一些调度，当消费完自己队列的，就去消费全局队列的，
       全局队列的也消费完，回去抢占其他p队列中的任务
    M：M是go运行时对操作系统内核的虚拟，M与内核线程是一一对应，goroutine最终是要放到M上运行的。
    三者的关系：p管理着一组G挂在M上
    单从系统调度的角度上来讲：Goroutine是由go运行时自己的调度器调度的，这个调度器使用了一个M：N的调度技术：
    1.goroutine的调度是在用户态下完成的，不涉及用户态和内核态的转换
    2.充分的使用了多核的硬件资源，把若干个goroutine均分到物理线程上

2.go的调度过程：
    G的生命周期：g从创建、保存、被获取、调度和执行、阻塞、销毁。

3.work stealing 机制：
    M首先会从本地队列p中获取goroutine，如果本地队列的p为空，则从全局队列中获取、如果全局队列也为空、则从其他本地队列p中偷取一半的goroutine。
    该机制可以防止M空转，最大化的利用线程的效率。

4.hand off机制：
    如果M在执行G的同时发生了系统调用阻塞，同时阻塞M和G，此时P会和当前的M解绑，并寻找新的M，这种阻塞后释放p的方式成为hand off机制

## 内存管理
1.简述 Golang 垃圾回收的机制
    三色标记法：
    1.新创建的对象默认颜色是白色
    2.GC回收从根节点一次遍历所有对象，把遍历到的对象从白色集合放入灰色集合。
    3.循环遍历灰色集合，将灰色对象引用的对象从白色集合放入灰色集合，之后将此灰色对象放入黑色集合，直到灰色中无任何对象
    4.回收所有的白色标记表的对象.也就是回收垃圾
    缺点：需要STW，即要暂时停掉程序运行

    改进：混合写屏障机制
    通过混合写屏障，Golang实现了GC的增量与并发
    增量指的是: 将GC的过程打散，分多次执行来完成一次GC过程。
    并发指的是: GC过程中的一部分可以和用户程序一起并发执行。

    gc触发条件：
    1.手动gc
    2.内存增大了1倍
    3.默认2min触发了一次gc

2.go的gc如何调优：
    1.控制内存分配的数量、限制goroutine的数量
    2.少使用+连接string
    3.slice提前分配内存避免扩容
    4.避免map key'的对象过多，导致扫描时间增加
    5.变量复用，减少对象分配
    6.增大GoGC的值，降低gc的运行频率

3.go如何查看GC的信息：
    1.godebug
    2.go tool trace
    3.debug.ReadGCStats
    4.runtime.ReadMemStats

## 并发编程
1.go 有哪些方式可以安全读写共享变量：
    1.sync.Once
    2.channel
    3.sync.Mutex加锁

2.如何排查数据竞争问题
    go run -race main.go
