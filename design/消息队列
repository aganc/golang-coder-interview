## 消息队列
1，为什么使用消息队列：
    解耦、异步、削峰

2.rocketMQ和 Kafka 有什么区别；
    1.架构设计：RocketMQ采用了主从架构，包括了多个Broker节点和NameServer节点，可以水平扩展。Kafka采用了分布式发布-订阅的架构，包括了多个Broker节点和ZooKeeper节点。
    2.消息顺序性：RocketMQ注重消息的顺序性，在消息的生产和消费上提供了严格的有序保证。Kafka在分区级别上保证消息的顺序性，但在整体上无法保证全局有序。
    3.消息传输语义：RocketMQ提供了多种消息传输语义，包括可靠同步传输、可靠异步传输和单向传输。Kafka主要提供了至少一次的消息传输语义，不保证严格的交付保证。
    4.消息存储机制：RocketMQ使用预分配的方式来存储消息，即事先申请好存储空间，并将消息写入文件。Kafka使用顺序写入磁盘的方式存储消息，采用了批量写入和索引机制来提高性能。
    5.可用性和容错性：RocketMQ通过主从复制和故障转移机制来提供高可用性和容错性。Kafka通过副本机制来实现高可用性，每个分区都有多个副本。
    6.生态系统和扩展性：Kafka具有更广泛的生态系统，适用于大数据场景，与Apache Hadoop、Spark等工具集成紧密。RocketMQ在国内的应用更为广泛，与阿里巴巴的生态系统更加紧密。

    总结:选择使用RocketMQ还是Kafka取决于具体的业务需求和场景。如果对消息顺序性要求较高、关注大规模消息的传输保证以及阿里巴巴生态系统的集成，可以选择RocketMQ。如果对消息传输的吞吐量和延迟有更高要求，以及更广泛的生态系统和与大数据工具集成，可以选择Kafka。

3.如何保证消息队列的高可用？
    数据副本：不同节点持久化同一份数据，当某一节点上存储的数据丢失时，可以从副本上读取该数据
    服务副本：指多个节点能够提供同样的服务，每个节点都能力接受外部请求应进行相应的处理

4.如何保证消息消费的幂等性？
    1. 利用数据库的唯一约束实现幂等
    2. 为更新的数据设置前置条件：加版本号、时间戳
    3. 记录并检查操作：全局唯一ID

5.如何保证消息的可靠性传输？
    Kafka是多副本机制，leader+follow  topic+partition
    生产端：
        1.ack机制
        2.重试机制：retires重试次数 + 重试时间
    MQ本身：
        1.是否选举isr节点作为新的leader
        2.设置最小同步的副本数
        3.kafka的持久化来源于直接读写页缓存 + 定时刷盘 的方式 优化刷盘机制（多少条消息刷一次、隔多久刷一次、周期性刷盘）
        4.集群部署数据容灾
    消费端：手动提交位移，先处理消息后提交位移，可能会出现重复消费的情况，得通过代码程序保证幂等性。

